##### 为什么选择VUE，解决了什么问题？

- 是一套构建用户界面的渐进式框架。与其它重量级框架不同的是，Vue 被设计为可以自底向上逐层应用。
- 只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合
- 当与现代化工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动
- Vue.js 有声明式，响应式的数据绑定，组件化开发，虚拟 DOM 等技术，统一编程规范和模块等
- 模块化更方便组织和构建复杂应用，便于项目的扩展和维护

##### key 的作用和工作原理

- key 的作用主要是为了高效地更新虚拟 DOM
- 通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，减少 DOM 操作量，提高性能
- 若不设置 key 还可能在列表更新时，引发一些隐蔽的 bug
- Vue 在使用相同标签名元素的过滤或切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过滤效果

##### v-if 和 v-for 的优先级哪个高？

v-for 的优先级更高

 v-if 和 v-for 同时出现，每次渲染都会先执行循环，再判断条件，无论如何循环都不可避免，浪费了性能。

- 要避免出现这种情况，则在外层嵌套 template ，在这一层进行 v-if 判断，然后再内部进行 v-for 循环。

##### vue 组件化

组件化的定义：

- 组件是独立和可复用的代码组织单元，组件系统是 vue 核心特性之一
- 复用性： 程序中一些独立的功能和模块单独提取出来，然后切分为更小的块，这些块有独立的逻辑，有更好的复用性。
- 组件化的开发能大幅提高开发效率、测试性和复用性等。提升应用性能，组件应该是高内聚，低耦合的。

##### data 在组件内必须是函数，而 vue 的根实例则没有此限制？

- vue 组件可能存在多个实例，如果使用对象形式定义 data ，则会导致它们公用一个 data 对象，那么状态变更将会影响所有组件实例，这是不合理的。
- 用函数的形式，在实例化组件时，data 会被当做工厂函数返回一个全新的 data 对象，有效规避多实例之间状态污染问题
- 在 vue 中根实例只能有一个，所以不需要担心多实例的问题，所以根实例中的 data 可以是函数也可以是对象。

##### Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？

不会立即同步执行重新渲染。

- Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新
- Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
- 如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。

##### 批量异步更新策略

- Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。
- 只要观察到数据变化，就会自动开启一个队列，并缓冲在同一个事件循环中发生的所以数据改变。在缓冲时会去除重复数据，从而避免不必要的计算和 DOM 操作。

##### vue 性能优化的方法

- 路由懒加载 按需加载 项目打包的时候体积会大幅减小，访问项目时，这些组件也会按需进行加载，大大提升了项目性能。
- keep-alive 缓存页面  keep-alive 之后会缓存页面，第一次加载之后，关闭再次打开，页面不会重新渲染
- v-for遍历避免同时使用 v-if
- 长列表性能优化 如果列表是纯粹的数据展示，不会有任何的改变，就不需要做响应式。
- Object.freeze() 方法可以冻结一个对象，对象被冻结之后不能被修改，可以让性能大幅度提升。
- 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容
- 事件的销毁， vue组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件
- 图片懒加载，滚动到可视区域之后再开始加载。 可以使用三方的 vue-lazyload 库。
- 第三方插件按需引用 按需引入UI框架

##### computed 与 methods 、watch 的区别

computed 是计算属性，methods 内都是方法，所以调用不同分别为

- computed 是有缓存的，而 methods 没有缓存，所以 computed 性能比 methods 的好。
- computed 是计算某一个属性的改变，如果某一个值改变了，计算属性会监测到，然后进行返回值。
- watch 是监听某一个数据或路由，改变了才会响应，只有改变了才会执行操作。更多的是观察的作用,无缓存性,类似于某些数据的监听回调,每 当监听的数据变化时都会执行回调进行后续操作。
- 当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率, 并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的

##### Vue 中的 diff 算法

- diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比，将变化的地方更新在真实DOM上；

- 借助key通常可以非常精确找到相同节点 ，diff过程整体遵循深度优先、同层比较的策略

- 如果节点类型相同，则比较数据，修改数据；

- 如果节点不同，直接干掉节点及所有子节点，插入新的节点

- DOM操作是非常昂贵的，因此我们需要尽量地减少DOM操作。这就需要找出本次DOM必须更新的节点来更新，其他的不更新，这个找出的过程，就需要应用diff算法

  步骤：

- 步骤一：用JS对象模拟DOM树

- 步骤二：比较两棵虚拟DOM树的差异

- 步骤三：把差异应用到真正的DOM树上

##### props 和 data 的优先

props > methods > data > computed > watch

#####  Vue 组件之间的通信

1. 父传子

- 通过 props 传值
- 通过 refs 传值
- 通过 children 传值

2. 子传父

- $emit 自定义事件
- provide 和 inject

3. 兄弟组件之间

- 利用中央事件总线 bus 的 $emit 和 $on 。
- 笨办法，通过父组件共同传值

4. 跨层组件

- provide 和 inject

5. 没有关系的组件之间通信

- 可以使用 vuex 进行数据管理

##### Vue.js 双向绑定的原理

- `Vue.js 2.0` 采用数据劫持（Proxy 模式）结合发布者-订阅者模式（PubSub 模式）的方式，通过 `Object.defineProperty()`来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
- `Vue.js 3.0,` 放弃了`Object.defineProperty` ，使用更快的ES6原生 Proxy (访问对象拦截器, 也称代理器)

##### Vue.js 3.0 放弃defineProperty, 使用Proxy的原因

- 监控到数组下标的变化时，开销很大。所以Vue.js放弃了下标变化的检测；

- `Object.defineProperty`只能劫持对象的属性。`Object.defineProperty`需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。
- 而 Proxy 直接代理对象，不需要遍历操作。

- `Object.defineProperty`对新增属性需要手动进行Observe。vue 2时需要使用` vm.$set` 才能保证新增的属性也是响应式

- `Proxy`支持13种拦截操作，这是`defineProperty`所不具有的

- `Proxy` 作为新标准，长远来看，JS引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化

#####  Vue 2 中给 data 中的对象属性添加一个新的属性时会发生什么

- 视图并未刷新。这是因为在Vue实例创建时，新属性并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，

- 这时就需要使用Vue的全局 api $set()：`this.$set(this.obj, 'new_property', 'new_value')`、

##### DOM操作带来的性能问题

浏览器工作流程：

1. 解析HTML，产出对应的DOM树；

2. 解析CSS, 生成对应的CSS树；

3. 将1和2的结果结合生成一棵render树；

4. 生成页面的布局排列(flow)

5. 将布局绘制到显示设备上(paint)

其中第4步和第5步其实就是常说的页面**渲染**，而渲染的过程除了在页面首次加载时发生，在后续交互过程中，**DOM操作也会引起重新排列和重新绘制，渲染是需要较高性能代价的，尤其是重排的过程**

所以常见的优化思路都会提到一点: 为了尽可能减少重绘和重排次数，尽量把改变dom的操作集中在一起，因为写入操作会触发重绘或者重排，**并且浏览器的渲染队列机制是：当某个操作触发重排或重绘时，先把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行。**所以集中进行dom操作可以减少重绘重排次数。

关于DOM操作的影响范围问题：由于浏览器是基于流式布局的，所以一旦某个元素重排，它的内部节点会受到影响，而外部节点（兄弟节点和父级节点等等）是**有可能不受影响的，这种局部重排引起的影响比较小，所以也需要尽可能地每次只改动最需要的节点元素**

##### 什么是Virtual DOM

- vdom是虚拟`DOM(Virtual DOM)`的简称，指的是用JS模拟的DOM结构，将DOM变化的对比放在JS层来做。换而言之，**vdom就是JS对象**。

- Virtual Dom，也就是虚拟的Dom, 无论是在React还是Vue都有用到。它本身并不是任何技术栈所独有的设计，而是一种设计思路，或者说设计模式。

- Virtual DOM 本质上是JavaScript对象，是对真实DOM的的一种描述方式，类似JSON格式

- React中就是将JS元素的名称、属性和内容作为对象及其属性来创建Virtual DOM。

##### 为何需要Virtual DOM？

- 基于对象来表示的文档模型：根据DOM会被表示为如下一棵树: 树的每个分支的终点都是一个节点(node)，每个节点都包含着对象，包含一些节点属性。 这就是**基于对象来表示文档**。
- 具备跨平台的优势
- 提升渲染性能
- 减少了dom引擎和JS引擎的频繁切换带来的开销问题；
- 可能在计算比较后，最终只需要改动局部，可以较少很多不必要的重绘重排；
- 把必要的Dom操作尽量集中在一起做，减少重排次数

##### v-model 是如何实现的，语法糖实际是什么

- 作用在表单元素上`v-model="message"`等同于`v-bind:value="message" v-on:input="message=$event.target.value"`	
- 作用在组件上, 本质是一个父子组件通信的语法糖，通过prop和$.emit实现, 等同于`:value="message" @input=" $emit('input', $event.target.value)"`

##### vuex的核心概念

- state => 基本数据

- getters => 从基本数据派生的数据

- mutations => 修改数据，同步

- actions => 修改数据，异步 (Action 提交的是 mutation，而不是直接变更状态)

- modules => 模块化Vuex

##### vuex是什么？怎么使用？哪种功能场景使用它？

- Vue.js 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态，主要是为了多页面、多组件之间的通信。
- Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面
- 项目很简单，最好不要使用 Vuex，对于大型项目，Vuex 能够更好的帮助我们管理组件外部的状态，一般可以运用在购物车、登录状态、播放等场景中。

##### $route和$router的区别

- $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数  是一个对象
- $router是“路由实例”对象包括了路由的跳转方法，钩子函数等



